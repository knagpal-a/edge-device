{"version":3,"file":"form.js","sources":["../../src/blocks/form/form.ts"],"sourcesContent":["import { toCamelCase } from '../../utils/toCamelCase';\nimport { toClassName } from '../../utils/toClassName';\nimport './form.css';\n\ntype FormControlElement = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;\n\ninterface FieldConfig {\n  type?: string;\n  field?: string;\n  label?: string;\n  help?: string;\n  required?: string;\n  default?: string;\n  placeholder?: string;\n  options?: string;\n  conditional?: string;\n  value?: string;\n}\n\ntype FieldList = FieldConfig[];\n\n/**\n * Creates an HTML element with an optional class name\n * @param {string} tag - HTML tag name\n * @param {string} [className] - Optional CSS class name\n * @returns {HTMLElement} Created element\n */\nfunction createElement<K extends keyof HTMLElementTagNameMap>(\n  tag: K,\n  className?: string,\n): HTMLElementTagNameMap[K] {\n  const el = document.createElement(tag);\n  if (className) el.className = className;\n  return el;\n}\n\n/**\n * Generates a camelCase ID from a name and optional option\n * @param {string} name - Base name for the ID\n * @param {string} [option] - Optional value to append to the ID\n * @returns {string} Generated camelCase ID\n */\nfunction generateId(name: string, option: string | null = null): string {\n  const id = toCamelCase(name);\n  return option ? `${id}-${toCamelCase(option)}` : id;\n}\n\n/**\n * Creates a help text paragraph with a unique ID\n * @param {string} text - Help text content\n * @param {string} inputId - ID of the associated input field\n * @returns {HTMLParagraphElement} Help text element\n */\nfunction writeHelpText(text: string, inputId: string): HTMLParagraphElement {\n  const help = createElement('p', 'field-help-text');\n  help.textContent = text;\n  help.id = `${inputId}-help`;\n  return help;\n}\n\n/**\n * Creates a label or legend element\n * @param {string} text - Label text content\n * @param {string} [type='label'] - Either 'label' or 'legend'\n * @param {string} [id] - ID of the associated input (for 'label' type only)\n * @param {boolean} [required] - Whether the field is required\n * @returns {HTMLElement} Label or legend element\n */\nfunction buildLabel(\n  text: string,\n  type: 'label' | 'legend' = 'label',\n  id: string | null = null,\n  required = false,\n): HTMLElement {\n  const label = createElement(type);\n  label.textContent = text;\n  if (id && type === 'label') label.setAttribute('for', id);\n  if (required) label.dataset.required = 'true';\n  return label;\n}\n\n/**\n * Creates an input element with specified attributes\n * @param {Object} field - Field configuration object\n * @returns {HTMLInputElement} Input element\n */\nfunction buildInput(field: FieldConfig): HTMLInputElement {\n  const {\n    type, field: fieldName, required, default: defaultValue, placeholder,\n  } = field;\n\n  const input = createElement('input');\n  input.type = type || 'text';\n  input.id = generateId(fieldName || 'field');\n  input.name = input.id;\n  input.required = required === 'true';\n  if (defaultValue) input.value = defaultValue;\n  if (placeholder) input.placeholder = placeholder;\n  return input;\n}\n\n/**\n * Creates a textarea element\n * @param {Object} field - Field configuration object\n * @returns {HTMLTextAreaElement} Textarea element\n */\nfunction buildTextArea(field: FieldConfig): HTMLTextAreaElement {\n  const {\n    field: fieldName, required, default: defaultValue, placeholder,\n  } = field;\n\n  const textarea = createElement('textarea');\n  textarea.id = generateId(fieldName || 'field');\n  textarea.name = textarea.id;\n  textarea.required = required === 'true';\n  textarea.rows = 5;\n  if (defaultValue) textarea.value = defaultValue;\n  if (placeholder) textarea.placeholder = placeholder;\n  return textarea;\n}\n\n/**\n * Creates a radio/checkbox input for an option\n * @param {Object} field - Field configuration object\n * @param {string} option - Option value\n * @returns {HTMLInputElement} Radio/checkbox input\n */\nfunction buildOptionInput(field: FieldConfig, option: string): HTMLInputElement {\n  const {\n    type, field: fieldName, default: defaultValue, required,\n  } = field;\n  const id = generateId(fieldName || 'field', option);\n\n  const input = createElement('input');\n  input.type = type || 'text';\n  input.id = id;\n  input.name = generateId(fieldName || 'field');\n  input.value = option;\n  input.checked = option === defaultValue;\n  input.required = required === 'true';\n\n  return input;\n}\n\n/**\n * Creates a fieldset containing radio/checkbox options\n * @param {Object} field - Field configuration object\n * @param {string} controlled - Controlled field name\n * @returns {HTMLFieldSetElement} Fieldset containing options\n */\nfunction buildOptions(field: FieldConfig, controlled: string | null): HTMLFieldSetElement | null {\n  const {\n    type, options, label, required,\n  } = field;\n  if (!options) return null;\n\n  const fieldset = createElement('fieldset', `form-field ${type}-field`);\n  if (controlled) {\n    const controller = controlled.split('-')[0];\n    fieldset.dataset.controller = controller;\n    fieldset.dataset.condition = controlled;\n  }\n  fieldset.append(buildLabel(label || '', 'legend', null, required === 'true'));\n\n  options.split(',').forEach((o) => {\n    const option = o.trim();\n    const input = buildOptionInput(field, option);\n    const span = createElement('span');\n    const labelEl = buildLabel(option, 'label', input.id);\n    labelEl.prepend(input, span);\n    fieldset.append(labelEl);\n  });\n\n  return fieldset;\n}\n\n/**\n * Fetches select options from a remote URL\n * @param {URL} url - URL to fetch options from\n * @returns {Promise<Array<HTMLOptionElement>>} Array of option elements\n */\nasync function buildOptionsFromUrl(url: URL): Promise<HTMLOptionElement[]> {\n  const resp = await fetch(url);\n  const { data } = (await resp.json()) as { data: Array<{ option?: string; value?: string }> };\n  const options = data.map((o) => {\n    const { option, value } = o;\n    const optionEl = createElement('option');\n    if (option && value) {\n      optionEl.value = value;\n      optionEl.textContent = option;\n    } else if (option && !value) {\n      optionEl.value = option;\n      optionEl.textContent = option;\n    } else if (value && !option) {\n      optionEl.value = value;\n      optionEl.textContent = value;\n    }\n    return optionEl;\n  });\n  return options;\n}\n\n/**\n * Creates a select dropdown field\n * @param {Object} field - Field configuration object\n * @param {string} controlled - Controlled field name\n * @returns {HTMLElement} Wrapper div containing select element\n */\nfunction buildSelect(field: FieldConfig, controlled: string | null): HTMLElement | null {\n  const {\n    type, options, field: fieldName, label, required, placeholder,\n  } = field;\n  if (!options) return null;\n\n  const wrapper = createElement('div', `form-field ${(type || 'text')}-field`);\n  if (controlled) {\n    const controller = controlled.split('-')[0];\n    wrapper.dataset.controller = controller;\n    wrapper.dataset.condition = controlled;\n  }\n  wrapper.append(buildLabel(label || '', 'label', generateId(fieldName || 'field'), required === 'true'));\n\n  const select = createElement('select');\n  select.id = generateId(fieldName || 'field');\n  select.name = select.id;\n  select.required = required === 'true';\n  wrapper.append(select);\n\n  if (placeholder) {\n    const placeholderOption = createElement('option');\n    placeholderOption.value = '';\n    placeholderOption.textContent = placeholder;\n    placeholderOption.disabled = true;\n    placeholderOption.selected = true;\n    select.append(placeholderOption);\n  }\n\n  try {\n    const url = new URL(options);\n    buildOptionsFromUrl(url).then((os) => {\n      select.append(...os);\n    });\n  } catch (error) {\n    options.split(',').forEach((o) => {\n      const option = o.trim();\n      const optionEl = createElement('option');\n      optionEl.value = option;\n      optionEl.textContent = option;\n      select.append(optionEl);\n    });\n  }\n\n  return wrapper;\n}\n\n/**\n * Creates a toggle switch field (styled checkbox)\n * @param {Object} field - Field configuration object\n * @param {string} controlled - Controlled field name\n * @returns {HTMLElement} Wrapper div containing toggle switch\n */\nfunction buildToggle(field: FieldConfig, controlled: string | null): HTMLElement {\n  const {\n    label, required, default: defaultValue,\n  } = field;\n\n  const wrapper = createElement('div', 'form-field toggle-field');\n  if (controlled) {\n    const controller = controlled.split('-')[0];\n    wrapper.dataset.controller = controller;\n    wrapper.dataset.condition = controlled;\n  }\n\n  const input = buildOptionInput({ ...field, type: 'checkbox' }, defaultValue || 'true');\n  input.setAttribute('role', 'switch');\n  input.setAttribute('aria-checked', String(input.checked));\n\n  input.addEventListener('change', () => {\n    input.setAttribute('aria-checked', String(input.checked));\n  });\n\n  const span = createElement('span');\n  const labelEl = buildLabel(label || '', 'label', input.id, required === 'true');\n  labelEl.prepend(input, span);\n  wrapper.append(labelEl);\n\n  return wrapper;\n}\n\n/**\n * Creates a button element\n * @param {Object} field - Field configuration object\n * @returns {HTMLButtonElement} Button element\n */\nfunction buildButton(field: FieldConfig): HTMLButtonElement {\n  const { type, label } = field;\n  const button = createElement('button');\n  button.className = 'button';\n  button.type = (type as 'button' | 'submit' | 'reset') || 'button';\n  button.textContent = label || '';\n  if (type === 'reset') button.classList.add('secondary');\n  return button;\n}\n\n/**\n * Toggles visibility of conditional fields based on the selected input\n * @param {Event} e - Change event\n * @param {Map} controllerConfig - Map of controller names to controlled fields\n */\nfunction toggleConditional(e: Event, controllerConfig: Map<string, FormControlElement[]>) {\n  const { target } = e;\n  const controller = (target as HTMLInputElement).name;\n  // check if this is a controlling input\n  if (controllerConfig.has(controller)) {\n    const inputs = [...(controllerConfig.get(controller) || [])];\n    inputs.forEach((i) => {\n      const field = i.closest('.form-field') as HTMLElement;\n      const { condition } = field.dataset;\n      const conditionMet = condition\n        ? condition.includes(toClassName((target as HTMLInputElement).value))\n        : false;\n      field.setAttribute('aria-hidden', String(!conditionMet));\n\n      // toggle required and tabindex based on visibility\n      if (conditionMet) {\n        if (i.dataset.originalRequired === 'true') {\n          i.setAttribute('required', '');\n        }\n        i.removeAttribute('tabindex');\n      } else {\n        i.removeAttribute('required');\n        i.setAttribute('tabindex', '-1'); // remove from tab order when hidden\n      }\n    });\n  }\n}\n\n/**\n * Sets initial visibility of conditional fields based on default values.\n * @param {HTMLFormElement} form - Form element\n * @param {Map} controllerConfig - Map of controller names to controlled fields.\n */\nfunction initConditionals(form: HTMLFormElement, controllerConfig: Map<string, FormControlElement[]>) {\n  // for each controller, find its current value and apply conditions\n  controllerConfig.forEach((controlledInputs, controller) => {\n    // find the controlling input - could be radio/checkbox or select\n    let controllerValue: string | null = null;\n    const checked = form.querySelector(`[name=\"${controller}\"]:checked`) as HTMLInputElement | null;\n    const select = form.querySelector(`select[name=\"${controller}\"]`) as HTMLSelectElement | null;\n\n    if (checked) {\n      controllerValue = checked.value;\n    } else if (select) {\n      controllerValue = select.value;\n    }\n\n    if (controllerValue) {\n      const safeValue = controllerValue;\n      // set correct visibility for each controlled field\n      controlledInputs.forEach((input) => {\n        const field = input.closest('.form-field') as HTMLElement;\n        const { condition } = field.dataset;\n        const conditionMet = condition ? condition.includes(toClassName(safeValue)) : false;\n        field.setAttribute('aria-hidden', String(!conditionMet));\n\n        // store original required state and toggle based on visibility\n        if (input.hasAttribute('required')) {\n          // store original required state if not already stored\n          if (!input.dataset.originalRequired) {\n            input.dataset.originalRequired = 'true';\n          }\n\n          if (!conditionMet) {\n            input.removeAttribute('required');\n          }\n        }\n\n        // remove from tab order when hidden\n        if (conditionMet) {\n          input.removeAttribute('tabindex');\n        } else {\n          input.setAttribute('tabindex', '-1');\n        }\n      });\n    } else {\n      // if no input is checked, hide all controlled fields\n      controlledInputs.forEach((input) => {\n        const field = input.closest('.form-field') as HTMLElement;\n        field.setAttribute('aria-hidden', 'true');\n\n        // remove required attribute when hidden\n        if (input.hasAttribute('required')) {\n          // store original required state if not already stored\n          if (!input.dataset.originalRequired) {\n            input.dataset.originalRequired = 'true';\n          }\n          input.removeAttribute('required');\n        }\n\n        // remove from tab order when hidden\n        input.setAttribute('tabindex', '-1');\n      });\n    }\n  });\n}\n\n/**\n * Sets up conditional field visibility and ARIA relationships\n * @param {HTMLFormElement} form - Form element\n */\nfunction enableConditionals(form: HTMLFormElement) {\n  // find controlled fields\n  const controlled = [...form.querySelectorAll<HTMLElement>('[data-controller]')];\n\n  // create a map of controller names to controlled fields\n  const controllerConfig = new Map<string, FormControlElement[]>();\n\n  controlled.forEach((c) => {\n    const input = c.querySelector('input, textarea, select') as FormControlElement | null;\n    const { controller } = c.dataset;\n\n    // add to controller map\n    if (!input) return;\n    if (!controller) return;\n    if (!controllerConfig.has(controller)) controllerConfig.set(controller, []);\n    (controllerConfig.get(controller) || []).push(input);\n\n    // set up aria relationships\n    if (input && input.id) {\n      // find the controlling input(s)\n      const controllerInputs = form.querySelectorAll(`[name=\"${controller}\"]`);\n\n      // set aria-controls on controlling inputs\n      controllerInputs.forEach((controllerInput) => {\n        // get existing aria-controls or initialize empty\n        const existingControls = controllerInput.getAttribute('aria-controls') || '';\n        const controlsArray = existingControls.split(' ').filter((ec) => ec);\n\n        // add this input's id if not already present\n        if (!controlsArray.includes(input.id)) {\n          controlsArray.push(input.id);\n        }\n\n        // update aria-controls attribute\n        controllerInput.setAttribute('aria-controls', controlsArray.join(' '));\n\n        // set aria-controlledby on the controlled input\n        input.setAttribute('aria-controlledby', controllerInput.id);\n      });\n    }\n  });\n\n  // initialize conditional visibility\n  initConditionals(form, controllerConfig);\n\n  // add single event listener for ALL controlling inputs\n  form.addEventListener('change', (e) => {\n    toggleConditional(e, controllerConfig);\n  });\n}\n\n/**\n * Enables or disables all form elements\n * @param {HTMLFormElement} form - Form element\n * @param {boolean} [disabled=true] - Whether to disable the form\n */\nfunction toggleForm(form: HTMLFormElement, disabled = true) {\n  [...form.elements].forEach((el) => {\n    const control = el as FormControlElement;\n    if (control && 'disabled' in control) {\n      control.disabled = disabled;\n    }\n  });\n}\n\n/**\n * Generates form submission payload from form elements\n * @param {HTMLFormElement} form - Form element\n * @returns {Object} Payload object with form data\n */\nfunction generatePayload(form: HTMLFormElement): Record<string, string> {\n  const payload = {};\n  [...form.elements].forEach((field) => {\n    const typedField = field as HTMLInputElement;\n    if (typedField.name && !typedField.disabled) {\n      if (typedField.type === 'radio') {\n        if (typedField.checked) payload[typedField.name] = typedField.value;\n      } else if (typedField.type === 'checkbox') {\n        if (typedField.checked) {\n          payload[typedField.name] = payload[typedField.name]\n            ? `${payload[typedField.name]},${typedField.value}`\n            : typedField.value;\n        }\n      } else {\n        payload[typedField.name] = typedField.value;\n      }\n    }\n  });\n  return payload;\n}\n\n/**\n * Handles form submission\n * @param {HTMLFormElement} form - Form element to submit\n * @returns {Promise<void>}\n */\nasync function handleSubmit(form: HTMLFormElement): Promise<void> {\n  try {\n    const payload = generatePayload(form);\n    toggleForm(form);\n    if (!form.dataset.action) throw new Error('Missing form action');\n    const response = await fetch(form.dataset.action, {\n      method: 'POST',\n      body: JSON.stringify({ data: payload }),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n    if (response.ok) {\n      if (form.dataset.confirmation) {\n        window.location.href = form.dataset.confirmation;\n      }\n    } else {\n      const error = await response.text();\n      throw new Error(error);\n    }\n  } catch (error) {\n    // eslint-disable-next-line no-console\n    console.error(error);\n  } finally {\n    toggleForm(form, false);\n  }\n}\n\n/**\n * Sets up form submission handler\n * @param {HTMLFormElement} form - Form element\n * @param {string} submit - Submit URL\n * @param {Array<Object>} fields - Array of field configurations\n */\nfunction enableSubmission(form: HTMLFormElement, submit: string, fields: FieldList) {\n  form.dataset.action = submit;\n  const confirmation = fields.find((f) => f.type === 'confirmation');\n  if (confirmation) {\n    form.dataset.confirmation = confirmation.label || confirmation.default;\n  }\n\n  form.addEventListener('submit', (e) => {\n    e.preventDefault();\n\n    const valid = form.reportValidity();\n    if (valid) {\n      handleSubmit(form);\n    } else {\n      const firstInvalid = form.querySelector(':invalid:not(fieldset)') as HTMLElement | null;\n      if (firstInvalid) {\n        firstInvalid.focus();\n        firstInvalid.scrollIntoView({ behavior: 'smooth', block: 'center' });\n        firstInvalid.setAttribute('aria-invalid', 'true');\n      }\n    }\n  });\n\n  // clear aria-invalid on field change\n  form.addEventListener('input', (e) => {\n    const target = e.target as HTMLInputElement;\n    if (target?.hasAttribute('aria-invalid')) {\n      if (target.validity.valid) {\n        target.removeAttribute('aria-invalid');\n      }\n    }\n  });\n}\n\n/**\n * Creates a form field based on field configuration\n * @param {Object} field - Field configuration object\n * @returns {HTMLElement} Form field element (fieldset, div, or button)\n */\nfunction buildField(field: FieldConfig): HTMLElement {\n  const {\n    type, label, help, field: fieldName, conditional,\n  } = field;\n  const controlled = conditional || null;\n  const safeFieldName = fieldName || 'field';\n\n  if (type === 'hidden') {\n    return buildInput(field);\n  }\n\n  // submit/reset buttons stand alone\n  if (type === 'submit' || type === 'reset') {\n    return buildButton(field);\n  }\n\n  // radio/checkbox groups get a fieldset\n  if (type === 'radio' || type === 'checkbox') {\n    const fieldset = buildOptions(field, controlled);\n    if (fieldset && help) {\n      const helpText = writeHelpText(help, generateId(safeFieldName));\n      fieldset.append(helpText);\n    }\n    return fieldset || createElement('div');\n  }\n\n  if (type === 'toggle') {\n    const toggle = buildToggle(field, controlled);\n    if (help) {\n      const helpText = writeHelpText(help, generateId(safeFieldName));\n      toggle.append(helpText);\n    }\n    return toggle;\n  }\n\n  if (type === 'select') {\n    const select = buildSelect(field, controlled);\n    if (select && help) {\n      const helpText = writeHelpText(help, generateId(safeFieldName));\n      select.append(helpText);\n    }\n    return select || createElement('div');\n  }\n\n  // inputs and textareas get a wrapper div\n  const wrapper = createElement('div', `form-field ${type}-field`);\n  if (controlled) {\n    const controller = controlled.split('-')[0];\n    wrapper.dataset.controller = controller;\n    wrapper.dataset.condition = controlled;\n  }\n  const inputId = generateId(safeFieldName);\n  wrapper.append(buildLabel(label || '', 'label', inputId, field.required === 'true'));\n\n  // create help text first to get id\n  let helpText: HTMLParagraphElement | undefined;\n  if (help) {\n    helpText = writeHelpText(help, inputId);\n    wrapper.append(helpText);\n  }\n\n  const input = type === 'textarea' ? buildTextArea(field) : buildInput(field);\n\n  if (type === 'textarea') {\n    wrapper.append(input);\n  } else if (wrapper.firstChild) {\n    wrapper.insertBefore(input, wrapper.firstChild.nextSibling);\n  } else {\n    wrapper.append(input);\n  }\n\n  if (helpText) input.setAttribute('aria-describedby', helpText.id);\n\n  return wrapper;\n}\n\n/**\n * Creates a complete form from field configurations\n * @param {Array<Object>} fields - Array of field configurations\n * @returns {HTMLFormElement} Complete form element\n */\nfunction buildForm(fields: FieldList, submit?: string): HTMLFormElement {\n  const form = createElement('form');\n  form.setAttribute('novalidate', '');\n\n  // group buttons at the end\n  const buttons: FieldConfig[] = [];\n\n  fields.forEach((field) => {\n    if (field.type === 'submit' || field.type === 'reset') {\n      buttons.push(field);\n    } else if (field.type !== 'confirmation') {\n      form.append(buildField(field));\n    }\n  });\n\n  // add buttons in a wrapper (if any)\n  if (buttons.length) {\n    const buttonWrapper = createElement('div', 'button-wrapper');\n    buttons.forEach((button) => buttonWrapper.append(buildField(button)));\n    form.append(buttonWrapper);\n  }\n\n  enableConditionals(form);\n\n  if (submit) enableSubmission(form, submit, fields);\n\n  return form;\n}\n\nfunction getFormConfigValue(fields: FieldList, name: string, fallback = ''): string {\n  const entry = fields.find((field) => field.field === name);\n  if (!entry) return fallback;\n  if (entry.default) return entry.default;\n  if (entry.value) return entry.value;\n  return fallback;\n}\n\nfunction initOtpBehavior(form: HTMLFormElement, fields: FieldList) {\n  const otpFieldName = getFormConfigValue(fields, 'otpFieldName', 'otp');\n  const resendTimerSeconds = Number(getFormConfigValue(fields, 'resendTimerSeconds', '30'));\n  const resendLimit = Number(getFormConfigValue(fields, 'resendLimit', '3'));\n  const otpErrorThreshold = Number(getFormConfigValue(fields, 'otpErrorThreshold', '5'));\n  const resendLimitMessage = getFormConfigValue(\n    fields,\n    'resendLimitMessage',\n    'Resend OTP limit exhausted.',\n  );\n  const otpErrorRedirect = getFormConfigValue(fields, 'otpErrorRedirect', '');\n  const resendLabel = getFormConfigValue(fields, 'resendLabel', 'Resend OTP');\n  const resendLoaderLabel = getFormConfigValue(fields, 'resendLoaderLabel', 'Resend available in');\n\n  const otpInput = form.querySelector(`input[name=\"${toCamelCase(otpFieldName)}\"]`) as HTMLInputElement | null;\n  if (!otpInput) return;\n\n  const otpField = otpInput.closest('.form-field') as HTMLElement | null;\n  if (!otpField) return;\n\n  const resendWrapper = createElement('div', 'otp-resend');\n  const loader = createElement('div', 'otp-resend__loader');\n  const loaderText = createElement('span', 'otp-resend__loader-text');\n  const timerText = createElement('span', 'otp-resend__timer');\n  loader.append(loaderText, timerText);\n\n  const resendButton = createElement('button', 'otp-resend__button');\n  resendButton.type = 'button';\n  resendButton.textContent = resendLabel;\n\n  const limitMessage = createElement('div', 'otp-resend__message');\n  limitMessage.textContent = resendLimitMessage;\n\n  resendWrapper.append(loader, resendButton, limitMessage);\n  otpField.append(resendWrapper);\n\n  let resendCount = 0;\n  let timerId: number | undefined;\n\n  const setVisibility = (state: 'loading' | 'ready' | 'limit') => {\n    loader.style.display = state === 'loading' ? 'flex' : 'none';\n    resendButton.style.display = state === 'ready' ? 'inline-flex' : 'none';\n    limitMessage.style.display = state === 'limit' ? 'block' : 'none';\n  };\n\n  const startTimer = (duration: number) => {\n    let remaining = Number.isFinite(duration) ? duration : 0;\n    loaderText.textContent = resendLoaderLabel;\n    setVisibility('loading');\n\n    const tick = () => {\n      timerText.textContent = ` ${remaining}s`;\n      if (remaining <= 0) {\n        if (timerId !== undefined) {\n          window.clearInterval(timerId);\n        }\n        timerId = undefined;\n        setVisibility('ready');\n      }\n      remaining -= 1;\n    };\n\n    tick();\n    timerId = window.setInterval(tick, 1000);\n  };\n\n  startTimer(resendTimerSeconds);\n\n  resendButton.addEventListener('click', () => {\n    resendCount += 1;\n    if (resendCount > resendLimit) {\n      setVisibility('limit');\n      return;\n    }\n\n    form.dispatchEvent(new CustomEvent('otp:resend', { bubbles: true }));\n    startTimer(resendTimerSeconds);\n  });\n\n  let otpErrorCount = 0;\n\n  form.addEventListener('submit', () => {\n    if (otpInput && !otpInput.checkValidity()) {\n      otpErrorCount += 1;\n      if (otpErrorThreshold && otpErrorCount >= otpErrorThreshold && otpErrorRedirect) {\n        window.location.href = otpErrorRedirect;\n      }\n    }\n  });\n}\n\n/**\n * Initializes form block with data from JSON endpoint\n * @param {HTMLElement} block - Form block element\n */\nexport default function decorate(block: HTMLElement) {\n  block.style.visibility = 'hidden';\n  const links = [...block.querySelectorAll<HTMLAnchorElement>('a[href]')];\n  const [source, submit] = links.map((a) => a.href);\n  if (source) {\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach(async (entry) => {\n        if (entry.isIntersecting) {\n          try {\n            const resp = await fetch(new URL(source, window.location.origin));\n            if (!resp.ok) throw new Error(`${resp.status}: ${resp.statusText}`);\n            const { data } = await resp.json();\n            if (!data) throw new Error(`No form fields at ${source}`);\n            const form = buildForm(data, submit);\n            initOtpBehavior(form, data);\n            block.replaceChildren(form);\n            block.removeAttribute('style');\n          } catch (error) {\n            // eslint-disable-next-line no-console\n            console.error('Could not build form from', source, error);\n            if (block.parentElement) block.parentElement.remove();\n          }\n          observer.disconnect();\n        }\n      });\n    }, { threshold: 0 });\n\n    observer.observe(block);\n  } else {\n    // eslint-disable-next-line no-console\n    console.error('Unable to create form without source');\n    if (block.parentElement) block.parentElement.remove();\n  }\n}\n"],"names":["createElement","tag","className","el","generateId","name","option","id","toCamelCase","writeHelpText","text","inputId","help","buildLabel","type","required","label","buildInput","field","fieldName","defaultValue","placeholder","input","buildTextArea","textarea","buildOptionInput","buildOptions","controlled","options","fieldset","controller","o","span","labelEl","buildOptionsFromUrl","url","resp","data","value","optionEl","buildSelect","wrapper","select","placeholderOption","os","buildToggle","buildButton","button","toggleConditional","e","controllerConfig","target","i","condition","conditionMet","toClassName","initConditionals","form","controlledInputs","controllerValue","checked","safeValue","enableConditionals","c","controllerInput","controlsArray","ec","toggleForm","disabled","control","generatePayload","payload","typedField","handleSubmit","response","error","enableSubmission","submit","fields","confirmation","f","firstInvalid","buildField","conditional","safeFieldName","helpText","toggle","buildForm","buttons","buttonWrapper","getFormConfigValue","fallback","entry","initOtpBehavior","otpFieldName","resendTimerSeconds","resendLimit","otpErrorThreshold","resendLimitMessage","otpErrorRedirect","resendLabel","resendLoaderLabel","otpInput","otpField","resendWrapper","loader","loaderText","timerText","resendButton","limitMessage","resendCount","timerId","setVisibility","state","startTimer","duration","remaining","tick","otpErrorCount","decorate","block","links","source","a","observer","entries"],"mappings":"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"}