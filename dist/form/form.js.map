{"version":3,"file":"form.js","sources":["../../src/blocks/form/form.ts"],"sourcesContent":["import { toCamelCase } from '../../utils/toCamelCase';\nimport { toClassName } from '../../utils/toClassName';\nimport './form.css';\n\ntype FormControlElement = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;\n\ninterface FieldConfig {\n  type?: string;\n  field?: string;\n  label?: string;\n  help?: string;\n  required?: string;\n  default?: string;\n  placeholder?: string;\n  options?: string;\n  conditional?: string;\n  value?: string;\n  pattern?: string;\n  maxlength?: string;\n  inputmode?: string;\n}\n\ntype FieldList = FieldConfig[];\n\n/**\n * Creates an HTML element with an optional class name\n * @param {string} tag - HTML tag name\n * @param {string} [className] - Optional CSS class name\n * @returns {HTMLElement} Created element\n */\nfunction createElement<K extends keyof HTMLElementTagNameMap>(\n  tag: K,\n  className?: string,\n): HTMLElementTagNameMap[K] {\n  const el = document.createElement(tag);\n  if (className) el.className = className;\n  return el;\n}\n\n/**\n * Generates a camelCase ID from a name and optional option\n * @param {string} name - Base name for the ID\n * @param {string} [option] - Optional value to append to the ID\n * @returns {string} Generated camelCase ID\n */\nfunction generateId(name: string, option: string | null = null): string {\n  const id = toCamelCase(name);\n  return option ? `${id}-${toCamelCase(option)}` : id;\n}\n\n/**\n * Creates a help text paragraph with a unique ID\n * @param {string} text - Help text content\n * @param {string} inputId - ID of the associated input field\n * @returns {HTMLParagraphElement} Help text element\n */\nfunction writeHelpText(text: string, inputId: string): HTMLParagraphElement {\n  const help = createElement('p', 'field-help-text');\n  help.textContent = text;\n  help.id = `${inputId}-help`;\n  return help;\n}\n\n/**\n * Creates a label or legend element\n * @param {string} text - Label text content\n * @param {string} [type='label'] - Either 'label' or 'legend'\n * @param {string} [id] - ID of the associated input (for 'label' type only)\n * @param {boolean} [required] - Whether the field is required\n * @returns {HTMLElement} Label or legend element\n */\nfunction buildLabel(\n  text: string,\n  type: 'label' | 'legend' = 'label',\n  id: string | null = null,\n  required = false,\n): HTMLElement {\n  const label = createElement(type);\n  label.textContent = text;\n  if (id && type === 'label') label.setAttribute('for', id);\n  if (required) label.dataset.required = 'true';\n  return label;\n}\n\n/**\n * Creates an input element with specified attributes\n * @param {Object} field - Field configuration object\n * @returns {HTMLInputElement} Input element\n */\nfunction buildInput(field: FieldConfig): HTMLInputElement {\n  const {\n    type,\n    field: fieldName,\n    required,\n    default: defaultValue,\n    placeholder,\n    pattern,\n    maxlength,\n    inputmode,\n  } = field;\n\n  const input = createElement('input');\n  input.type = type || 'text';\n  input.id = generateId(fieldName || 'field');\n  input.name = input.id;\n  input.required = required === 'true';\n  if (defaultValue) input.value = defaultValue;\n  if (placeholder) input.placeholder = placeholder;\n  if (pattern) input.pattern = pattern;\n  if (maxlength) input.maxLength = Number(maxlength);\n  if (inputmode) input.inputMode = inputmode as HTMLInputElement['inputMode'];\n  return input;\n}\n\n/**\n * Creates a textarea element\n * @param {Object} field - Field configuration object\n * @returns {HTMLTextAreaElement} Textarea element\n */\nfunction buildTextArea(field: FieldConfig): HTMLTextAreaElement {\n  const {\n    field: fieldName, required, default: defaultValue, placeholder,\n  } = field;\n\n  const textarea = createElement('textarea');\n  textarea.id = generateId(fieldName || 'field');\n  textarea.name = textarea.id;\n  textarea.required = required === 'true';\n  textarea.rows = 5;\n  if (defaultValue) textarea.value = defaultValue;\n  if (placeholder) textarea.placeholder = placeholder;\n  return textarea;\n}\n\n/**\n * Creates a radio/checkbox input for an option\n * @param {Object} field - Field configuration object\n * @param {string} option - Option value\n * @returns {HTMLInputElement} Radio/checkbox input\n */\nfunction buildOptionInput(field: FieldConfig, option: string): HTMLInputElement {\n  const {\n    type, field: fieldName, default: defaultValue, required,\n  } = field;\n  const id = generateId(fieldName || 'field', option);\n\n  const input = createElement('input');\n  input.type = type || 'text';\n  input.id = id;\n  input.name = generateId(fieldName || 'field');\n  input.value = option;\n  input.checked = option === defaultValue;\n  input.required = required === 'true';\n\n  return input;\n}\n\n/**\n * Creates a fieldset containing radio/checkbox options\n * @param {Object} field - Field configuration object\n * @param {string} controlled - Controlled field name\n * @returns {HTMLFieldSetElement} Fieldset containing options\n */\nfunction buildOptions(field: FieldConfig, controlled: string | null): HTMLFieldSetElement | null {\n  const {\n    type, options, label, required,\n  } = field;\n  if (!options) return null;\n\n  const fieldset = createElement('fieldset', `form-field ${type}-field`);\n  if (controlled) {\n    const controller = controlled.split('-')[0];\n    fieldset.dataset.controller = controller;\n    fieldset.dataset.condition = controlled;\n  }\n  fieldset.append(buildLabel(label || '', 'legend', null, required === 'true'));\n\n  options.split(',').forEach((o) => {\n    const option = o.trim();\n    const input = buildOptionInput(field, option);\n    const span = createElement('span');\n    const labelEl = buildLabel(option, 'label', input.id);\n    labelEl.prepend(input, span);\n    fieldset.append(labelEl);\n  });\n\n  return fieldset;\n}\n\n/**\n * Fetches select options from a remote URL\n * @param {URL} url - URL to fetch options from\n * @returns {Promise<Array<HTMLOptionElement>>} Array of option elements\n */\nasync function buildOptionsFromUrl(url: URL): Promise<HTMLOptionElement[]> {\n  const resp = await fetch(url);\n  const { data } = (await resp.json()) as { data: Array<{ option?: string; value?: string }> };\n  const options = data.map((o) => {\n    const { option, value } = o;\n    const optionEl = createElement('option');\n    if (option && value) {\n      optionEl.value = value;\n      optionEl.textContent = option;\n    } else if (option && !value) {\n      optionEl.value = option;\n      optionEl.textContent = option;\n    } else if (value && !option) {\n      optionEl.value = value;\n      optionEl.textContent = value;\n    }\n    return optionEl;\n  });\n  return options;\n}\n\n/**\n * Creates a select dropdown field\n * @param {Object} field - Field configuration object\n * @param {string} controlled - Controlled field name\n * @returns {HTMLElement} Wrapper div containing select element\n */\nfunction buildSelect(field: FieldConfig, controlled: string | null): HTMLElement | null {\n  const {\n    type, options, field: fieldName, label, required, placeholder,\n  } = field;\n  if (!options) return null;\n\n  const wrapper = createElement('div', `form-field ${(type || 'text')}-field`);\n  if (controlled) {\n    const controller = controlled.split('-')[0];\n    wrapper.dataset.controller = controller;\n    wrapper.dataset.condition = controlled;\n  }\n  wrapper.append(buildLabel(label || '', 'label', generateId(fieldName || 'field'), required === 'true'));\n\n  const select = createElement('select');\n  select.id = generateId(fieldName || 'field');\n  select.name = select.id;\n  select.required = required === 'true';\n  wrapper.append(select);\n\n  if (placeholder) {\n    const placeholderOption = createElement('option');\n    placeholderOption.value = '';\n    placeholderOption.textContent = placeholder;\n    placeholderOption.disabled = true;\n    placeholderOption.selected = true;\n    select.append(placeholderOption);\n  }\n\n  try {\n    const url = new URL(options);\n    buildOptionsFromUrl(url).then((os) => {\n      select.append(...os);\n    });\n  } catch (error) {\n    options.split(',').forEach((o) => {\n      const option = o.trim();\n      const optionEl = createElement('option');\n      optionEl.value = option;\n      optionEl.textContent = option;\n      select.append(optionEl);\n    });\n  }\n\n  return wrapper;\n}\n\n/**\n * Creates a toggle switch field (styled checkbox)\n * @param {Object} field - Field configuration object\n * @param {string} controlled - Controlled field name\n * @returns {HTMLElement} Wrapper div containing toggle switch\n */\nfunction buildToggle(field: FieldConfig, controlled: string | null): HTMLElement {\n  const {\n    label, required, default: defaultValue,\n  } = field;\n\n  const wrapper = createElement('div', 'form-field toggle-field');\n  if (controlled) {\n    const controller = controlled.split('-')[0];\n    wrapper.dataset.controller = controller;\n    wrapper.dataset.condition = controlled;\n  }\n\n  const input = buildOptionInput({ ...field, type: 'checkbox' }, defaultValue || 'true');\n  input.setAttribute('role', 'switch');\n  input.setAttribute('aria-checked', String(input.checked));\n\n  input.addEventListener('change', () => {\n    input.setAttribute('aria-checked', String(input.checked));\n  });\n\n  const span = createElement('span');\n  const labelEl = buildLabel(label || '', 'label', input.id, required === 'true');\n  labelEl.prepend(input, span);\n  wrapper.append(labelEl);\n\n  return wrapper;\n}\n\n/**\n * Creates a button element\n * @param {Object} field - Field configuration object\n * @returns {HTMLButtonElement} Button element\n */\nfunction buildButton(field: FieldConfig): HTMLButtonElement {\n  const { type, label } = field;\n  const button = createElement('button');\n  button.className = 'button';\n  button.type = (type as 'button' | 'submit' | 'reset') || 'button';\n  button.textContent = label || '';\n  if (type === 'reset') button.classList.add('secondary');\n  return button;\n}\n\n/**\n * Toggles visibility of conditional fields based on the selected input\n * @param {Event} e - Change event\n * @param {Map} controllerConfig - Map of controller names to controlled fields\n */\nfunction toggleConditional(e: Event, controllerConfig: Map<string, FormControlElement[]>) {\n  const { target } = e;\n  const controller = (target as HTMLInputElement).name;\n  // check if this is a controlling input\n  if (controllerConfig.has(controller)) {\n    const inputs = [...(controllerConfig.get(controller) || [])];\n    inputs.forEach((i) => {\n      const field = i.closest('.form-field') as HTMLElement;\n      const { condition } = field.dataset;\n      const conditionMet = condition\n        ? condition.includes(toClassName((target as HTMLInputElement).value))\n        : false;\n      field.setAttribute('aria-hidden', String(!conditionMet));\n\n      // toggle required and tabindex based on visibility\n      if (conditionMet) {\n        if (i.dataset.originalRequired === 'true') {\n          i.setAttribute('required', '');\n        }\n        i.removeAttribute('tabindex');\n      } else {\n        i.removeAttribute('required');\n        i.setAttribute('tabindex', '-1'); // remove from tab order when hidden\n      }\n    });\n  }\n}\n\n/**\n * Sets initial visibility of conditional fields based on default values.\n * @param {HTMLFormElement} form - Form element\n * @param {Map} controllerConfig - Map of controller names to controlled fields.\n */\nfunction initConditionals(form: HTMLFormElement, controllerConfig: Map<string, FormControlElement[]>) {\n  // for each controller, find its current value and apply conditions\n  controllerConfig.forEach((controlledInputs, controller) => {\n    // find the controlling input - could be radio/checkbox or select\n    let controllerValue: string | null = null;\n    const checked = form.querySelector(`[name=\"${controller}\"]:checked`) as HTMLInputElement | null;\n    const select = form.querySelector(`select[name=\"${controller}\"]`) as HTMLSelectElement | null;\n\n    if (checked) {\n      controllerValue = checked.value;\n    } else if (select) {\n      controllerValue = select.value;\n    }\n\n    if (controllerValue) {\n      const safeValue = controllerValue;\n      // set correct visibility for each controlled field\n      controlledInputs.forEach((input) => {\n        const field = input.closest('.form-field') as HTMLElement;\n        const { condition } = field.dataset;\n        const conditionMet = condition ? condition.includes(toClassName(safeValue)) : false;\n        field.setAttribute('aria-hidden', String(!conditionMet));\n\n        // store original required state and toggle based on visibility\n        if (input.hasAttribute('required')) {\n          // store original required state if not already stored\n          if (!input.dataset.originalRequired) {\n            input.dataset.originalRequired = 'true';\n          }\n\n          if (!conditionMet) {\n            input.removeAttribute('required');\n          }\n        }\n\n        // remove from tab order when hidden\n        if (conditionMet) {\n          input.removeAttribute('tabindex');\n        } else {\n          input.setAttribute('tabindex', '-1');\n        }\n      });\n    } else {\n      // if no input is checked, hide all controlled fields\n      controlledInputs.forEach((input) => {\n        const field = input.closest('.form-field') as HTMLElement;\n        field.setAttribute('aria-hidden', 'true');\n\n        // remove required attribute when hidden\n        if (input.hasAttribute('required')) {\n          // store original required state if not already stored\n          if (!input.dataset.originalRequired) {\n            input.dataset.originalRequired = 'true';\n          }\n          input.removeAttribute('required');\n        }\n\n        // remove from tab order when hidden\n        input.setAttribute('tabindex', '-1');\n      });\n    }\n  });\n}\n\n/**\n * Sets up conditional field visibility and ARIA relationships\n * @param {HTMLFormElement} form - Form element\n */\nfunction enableConditionals(form: HTMLFormElement) {\n  // find controlled fields\n  const controlled = [...form.querySelectorAll<HTMLElement>('[data-controller]')];\n\n  // create a map of controller names to controlled fields\n  const controllerConfig = new Map<string, FormControlElement[]>();\n\n  controlled.forEach((c) => {\n    const input = c.querySelector('input, textarea, select') as FormControlElement | null;\n    const { controller } = c.dataset;\n\n    // add to controller map\n    if (!input) return;\n    if (!controller) return;\n    if (!controllerConfig.has(controller)) controllerConfig.set(controller, []);\n    (controllerConfig.get(controller) || []).push(input);\n\n    // set up aria relationships\n    if (input && input.id) {\n      // find the controlling input(s)\n      const controllerInputs = form.querySelectorAll(`[name=\"${controller}\"]`);\n\n      // set aria-controls on controlling inputs\n      controllerInputs.forEach((controllerInput) => {\n        // get existing aria-controls or initialize empty\n        const existingControls = controllerInput.getAttribute('aria-controls') || '';\n        const controlsArray = existingControls.split(' ').filter((ec) => ec);\n\n        // add this input's id if not already present\n        if (!controlsArray.includes(input.id)) {\n          controlsArray.push(input.id);\n        }\n\n        // update aria-controls attribute\n        controllerInput.setAttribute('aria-controls', controlsArray.join(' '));\n\n        // set aria-controlledby on the controlled input\n        input.setAttribute('aria-controlledby', controllerInput.id);\n      });\n    }\n  });\n\n  // initialize conditional visibility\n  initConditionals(form, controllerConfig);\n\n  // add single event listener for ALL controlling inputs\n  form.addEventListener('change', (e) => {\n    toggleConditional(e, controllerConfig);\n  });\n}\n\n/**\n * Enables or disables all form elements\n * @param {HTMLFormElement} form - Form element\n * @param {boolean} [disabled=true] - Whether to disable the form\n */\nfunction toggleForm(form: HTMLFormElement, disabled = true) {\n  [...form.elements].forEach((el) => {\n    const control = el as FormControlElement;\n    if (control && 'disabled' in control) {\n      control.disabled = disabled;\n    }\n  });\n}\n\n/**\n * Generates form submission payload from form elements\n * @param {HTMLFormElement} form - Form element\n * @returns {Object} Payload object with form data\n */\nfunction generatePayload(form: HTMLFormElement): Record<string, string> {\n  const payload = {};\n  [...form.elements].forEach((field) => {\n    const typedField = field as HTMLInputElement;\n    if (typedField.name && !typedField.disabled) {\n      if (typedField.type === 'radio') {\n        if (typedField.checked) payload[typedField.name] = typedField.value;\n      } else if (typedField.type === 'checkbox') {\n        if (typedField.checked) {\n          payload[typedField.name] = payload[typedField.name]\n            ? `${payload[typedField.name]},${typedField.value}`\n            : typedField.value;\n        }\n      } else {\n        payload[typedField.name] = typedField.value;\n      }\n    }\n  });\n  return payload;\n}\n\n/**\n * Handles form submission\n * @param {HTMLFormElement} form - Form element to submit\n * @returns {Promise<void>}\n */\nasync function handleSubmit(form: HTMLFormElement): Promise<void> {\n  try {\n    const payload = generatePayload(form);\n    toggleForm(form);\n    if (!form.dataset.action) throw new Error('Missing form action');\n    const response = await fetch(form.dataset.action, {\n      method: 'POST',\n      body: JSON.stringify({ data: payload }),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n    if (response.ok) {\n      if (form.dataset.confirmation) {\n        window.location.href = form.dataset.confirmation;\n      }\n    } else {\n      const error = await response.text();\n      throw new Error(error);\n    }\n  } catch (error) {\n    // eslint-disable-next-line no-console\n    console.error(error);\n  } finally {\n    toggleForm(form, false);\n  }\n}\n\n/**\n * Sets up form submission handler\n * @param {HTMLFormElement} form - Form element\n * @param {string} submit - Submit URL\n * @param {Array<Object>} fields - Array of field configurations\n */\nfunction enableSubmission(form: HTMLFormElement, submit: string, fields: FieldList) {\n  form.dataset.action = submit;\n  const confirmation = fields.find((f) => f.type === 'confirmation');\n  if (confirmation) {\n    form.dataset.confirmation = confirmation.label || confirmation.default;\n  }\n\n  form.addEventListener('submit', (e) => {\n    e.preventDefault();\n\n    const valid = form.reportValidity();\n    if (valid) {\n      handleSubmit(form);\n    } else {\n      const firstInvalid = form.querySelector(':invalid:not(fieldset)') as HTMLElement | null;\n      if (firstInvalid) {\n        firstInvalid.focus();\n        firstInvalid.scrollIntoView({ behavior: 'smooth', block: 'center' });\n        firstInvalid.setAttribute('aria-invalid', 'true');\n      }\n    }\n  });\n\n  // clear aria-invalid on field change\n  form.addEventListener('input', (e) => {\n    const target = e.target as HTMLInputElement;\n    if (target?.hasAttribute('aria-invalid')) {\n      if (target.validity.valid) {\n        target.removeAttribute('aria-invalid');\n      }\n    }\n  });\n}\n\n/**\n * Creates a form field based on field configuration\n * @param {Object} field - Field configuration object\n * @returns {HTMLElement} Form field element (fieldset, div, or button)\n */\nfunction buildField(field: FieldConfig): HTMLElement {\n  const {\n    type, label, help, field: fieldName, conditional,\n  } = field;\n  const controlled = conditional || null;\n  const safeFieldName = fieldName || 'field';\n\n  if (type === 'hidden') {\n    return buildInput(field);\n  }\n\n  // submit/reset buttons stand alone\n  if (type === 'submit' || type === 'reset') {\n    return buildButton(field);\n  }\n\n  // radio/checkbox groups get a fieldset\n  if (type === 'radio' || type === 'checkbox') {\n    const fieldset = buildOptions(field, controlled);\n    if (fieldset && help) {\n      const helpText = writeHelpText(help, generateId(safeFieldName));\n      fieldset.append(helpText);\n    }\n    return fieldset || createElement('div');\n  }\n\n  if (type === 'toggle') {\n    const toggle = buildToggle(field, controlled);\n    if (help) {\n      const helpText = writeHelpText(help, generateId(safeFieldName));\n      toggle.append(helpText);\n    }\n    return toggle;\n  }\n\n  if (type === 'select') {\n    const select = buildSelect(field, controlled);\n    if (select && help) {\n      const helpText = writeHelpText(help, generateId(safeFieldName));\n      select.append(helpText);\n    }\n    return select || createElement('div');\n  }\n\n  // inputs and textareas get a wrapper div\n  const wrapper = createElement('div', `form-field ${type}-field`);\n  if (controlled) {\n    const controller = controlled.split('-')[0];\n    wrapper.dataset.controller = controller;\n    wrapper.dataset.condition = controlled;\n  }\n  const inputId = generateId(safeFieldName);\n  wrapper.append(buildLabel(label || '', 'label', inputId, field.required === 'true'));\n\n  // create help text first to get id\n  let helpText: HTMLParagraphElement | undefined;\n  if (help) {\n    helpText = writeHelpText(help, inputId);\n    wrapper.append(helpText);\n  }\n\n  const input = type === 'textarea' ? buildTextArea(field) : buildInput(field);\n\n  if (type === 'textarea') {\n    wrapper.append(input);\n  } else if (wrapper.firstChild) {\n    wrapper.insertBefore(input, wrapper.firstChild.nextSibling);\n  } else {\n    wrapper.append(input);\n  }\n\n  if (helpText) input.setAttribute('aria-describedby', helpText.id);\n\n  return wrapper;\n}\n\n/**\n * Creates a complete form from field configurations\n * @param {Array<Object>} fields - Array of field configurations\n * @returns {HTMLFormElement} Complete form element\n */\nfunction buildForm(fields: FieldList, submit?: string): HTMLFormElement {\n  const form = createElement('form');\n  form.setAttribute('novalidate', '');\n\n  // group buttons at the end\n  const buttons: FieldConfig[] = [];\n\n  fields.forEach((field) => {\n    if (field.type === 'submit' || field.type === 'reset') {\n      buttons.push(field);\n    } else if (field.type !== 'confirmation') {\n      form.append(buildField(field));\n    }\n  });\n\n  // add buttons in a wrapper (if any)\n  if (buttons.length) {\n    const buttonWrapper = createElement('div', 'button-wrapper');\n    buttons.forEach((button) => buttonWrapper.append(buildField(button)));\n    form.append(buttonWrapper);\n  }\n\n  enableConditionals(form);\n\n  if (submit) enableSubmission(form, submit, fields);\n\n  return form;\n}\n\nfunction getFormConfigValue(fields: FieldList, name: string, fallback = ''): string {\n  const entry = fields.find((field) => field.field === name);\n  if (!entry) return fallback;\n  if (entry.default) return entry.default;\n  if (entry.value) return entry.value;\n  return fallback;\n}\n\nfunction initOtpBehavior(form: HTMLFormElement, fields: FieldList) {\n  const otpFieldName = 'otp';\n  const resendTimerSeconds = 30;\n  const resendLimit = 3;\n  const otpErrorThreshold = 0;\n  const resendLimitMessage = getFormConfigValue(\n    fields,\n    'resendLimitMessage',\n    'Resend OTP limit exhausted.',\n  );\n  const otpErrorRedirect = '';\n  const resendLabel = 'Resend OTP';\n  const resendLoaderLabel = 'Resend available in';\n  const otpSuccessRedirect = '/thank-you';\n  const otpRetryMessage = 'Invalid OTP. Please try again.';\n\n  const otpInput = form.querySelector(`input[name=\"${toCamelCase(otpFieldName)}\"]`) as HTMLInputElement | null;\n  if (!otpInput) return;\n  const mobileInput = form.querySelector('input[name=\"mobile\"]') as HTMLInputElement | null;\n\n  const otpField = otpInput.closest('.form-field') as HTMLElement | null;\n  if (!otpField) return;\n\n  const resendWrapper = createElement('div', 'otp-resend');\n  const loader = createElement('div', 'otp-resend__loader');\n  const loaderText = createElement('span', 'otp-resend__loader-text');\n  const timerText = createElement('span', 'otp-resend__timer');\n  loader.append(loaderText, timerText);\n\n  const resendButton = createElement('button', 'otp-resend__button');\n  resendButton.type = 'button';\n  resendButton.textContent = resendLabel;\n\n  const limitMessage = createElement('div', 'otp-resend__message');\n  limitMessage.textContent = resendLimitMessage;\n\n  resendWrapper.append(loader, resendButton, limitMessage);\n  otpField.append(resendWrapper);\n\n  const otpRetry = createElement('div', 'otp-verify__message');\n  otpRetry.textContent = otpRetryMessage;\n  otpRetry.style.display = 'none';\n  otpField.append(otpRetry);\n\n  let resendCount = 0;\n  let timerId: number | undefined;\n  let timerStarted = false;\n\n  const setVisibility = (state: 'loading' | 'ready' | 'limit') => {\n    loader.style.display = state === 'loading' ? 'flex' : 'none';\n    resendButton.style.display = state === 'ready' ? 'inline-flex' : 'none';\n    limitMessage.style.display = state === 'limit' ? 'block' : 'none';\n  };\n\n  const resetVisibility = () => {\n    loader.style.display = 'none';\n    resendButton.style.display = 'none';\n    limitMessage.style.display = 'none';\n  };\n\n  const startTimer = (duration: number) => {\n    if (timerStarted) return;\n    timerStarted = true;\n    let remaining = Number.isFinite(duration) ? duration : 0;\n    loaderText.textContent = resendLoaderLabel;\n    setVisibility('loading');\n\n    const tick = () => {\n      timerText.textContent = ` ${remaining}s`;\n      if (remaining <= 0) {\n        if (timerId !== undefined) {\n          window.clearInterval(timerId);\n        }\n        timerId = undefined;\n        setVisibility('ready');\n      }\n      remaining -= 1;\n    };\n\n    tick();\n    timerId = window.setInterval(tick, 1000);\n  };\n\n  resetVisibility();\n\n  if (mobileInput) {\n    const maybeStartTimer = () => {\n      const digitsOnly = mobileInput.value.replace(/\\D/g, '');\n      if (digitsOnly.length >= 10) startTimer(resendTimerSeconds);\n    };\n    mobileInput.addEventListener('input', maybeStartTimer);\n    maybeStartTimer();\n  } else {\n    startTimer(resendTimerSeconds);\n  }\n\n  resendButton.addEventListener('click', () => {\n    resendCount += 1;\n    if (resendCount > resendLimit) {\n      setVisibility('limit');\n      return;\n    }\n\n    form.dispatchEvent(new CustomEvent('otp:resend', { bubbles: true }));\n    startTimer(resendTimerSeconds);\n  });\n\n  let otpErrorCount = 0;\n\n  form.addEventListener('submit', () => {\n    if (otpInput && !otpInput.checkValidity()) {\n      otpErrorCount += 1;\n      if (otpErrorThreshold && otpErrorCount >= otpErrorThreshold && otpErrorRedirect) {\n        window.location.href = otpErrorRedirect;\n      }\n    }\n  });\n\n  form.addEventListener('submit', (e) => {\n    e.preventDefault();\n    otpRetry.style.display = 'none';\n\n    const valid = form.reportValidity();\n    if (!valid) {\n      const firstInvalid = form.querySelector(':invalid:not(fieldset)') as HTMLElement | null;\n      if (firstInvalid) {\n        firstInvalid.focus();\n        firstInvalid.scrollIntoView({ behavior: 'smooth', block: 'center' });\n        firstInvalid.setAttribute('aria-invalid', 'true');\n      }\n      return;\n    }\n\n    if (otpInput.value === '12345') {\n      window.location.href = otpSuccessRedirect;\n    } else {\n      otpRetry.style.display = 'block';\n      otpInput.focus();\n    }\n  });\n}\n\n/**\n * Initializes form block with data from JSON endpoint\n * @param {HTMLElement} block - Form block element\n */\nexport default function decorate(block: HTMLElement) {\n  block.style.visibility = 'hidden';\n  const configFields: FieldList = [];\n  block.querySelectorAll<HTMLTableRowElement>('tr').forEach((row) => {\n    const cells = row.querySelectorAll<HTMLTableCellElement>('td, th');\n    if (cells.length >= 2) {\n      const key = cells[0].textContent?.trim() || '';\n      const value = cells[1].textContent?.trim() || '';\n      if (key) {\n        configFields.push({\n          field: key,\n          type: 'hidden',\n          default: value,\n        });\n      }\n    }\n  });\n\n  const staticFields: FieldList = [\n    {\n      field: 'firstName',\n      type: 'text',\n      label: 'First name',\n      placeholder: 'Enter first name',\n      required: 'true',\n    },\n    {\n      field: 'lastName',\n      type: 'text',\n      label: 'Last name',\n      placeholder: 'Enter last name',\n      required: 'true',\n    },\n    {\n      field: 'mobile',\n      type: 'tel',\n      label: 'Mobile number',\n      placeholder: 'Enter mobile number',\n      required: 'true',\n      inputmode: 'numeric',\n      maxlength: '10',\n      pattern: '\\\\\\\\d{10}',\n    },\n    {\n      field: 'otp',\n      type: 'text',\n      label: 'OTP',\n      placeholder: 'Enter OTP',\n      required: 'true',\n    },\n    {\n      field: 'submit',\n      type: 'submit',\n      label: 'Verify OTP',\n    },\n  ];\n\n  const form = buildForm(staticFields);\n  initOtpBehavior(form, configFields);\n  block.replaceChildren(form);\n  block.removeAttribute('style');\n}\n"],"names":["createElement","tag","className","el","generateId","name","option","id","toCamelCase","writeHelpText","text","inputId","help","buildLabel","type","required","label","buildInput","field","fieldName","defaultValue","placeholder","pattern","maxlength","inputmode","input","buildTextArea","textarea","buildOptionInput","buildOptions","controlled","options","fieldset","controller","span","labelEl","buildOptionsFromUrl","url","resp","data","o","value","optionEl","buildSelect","wrapper","select","placeholderOption","os","buildToggle","buildButton","button","toggleConditional","controllerConfig","target","condition","conditionMet","toClassName","initConditionals","form","controlledInputs","controllerValue","checked","safeValue","enableConditionals","c","controllerInput","controlsArray","ec","e","buildField","conditional","safeFieldName","helpText","toggle","buildForm","fields","submit","buttons","buttonWrapper","getFormConfigValue","fallback","entry","initOtpBehavior","otpFieldName","resendLimitMessage","resendLabel","resendLoaderLabel","otpSuccessRedirect","otpRetryMessage","otpInput","mobileInput","otpField","resendWrapper","loader","loaderText","timerText","resendButton","limitMessage","otpRetry","resendCount","timerId","timerStarted","setVisibility","state","resetVisibility","startTimer","duration","remaining","tick","maybeStartTimer","firstInvalid","decorate","block","configFields","row","cells","key","_a","_b"],"mappings":"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"}