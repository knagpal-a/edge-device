{"version":3,"file":"form.js","sources":["../../src/blocks/form/form.ts"],"sourcesContent":["import { toCamelCase } from '../../utils/toCamelCase';\nimport { toClassName } from '../../utils/toClassName';\nimport './form.css';\n\ntype FormControlElement = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;\n\ninterface FieldConfig {\n  type?: string;\n  field?: string;\n  label?: string;\n  help?: string;\n  required?: string;\n  default?: string;\n  placeholder?: string;\n  options?: string;\n  conditional?: string;\n  value?: string;\n}\n\ntype FieldList = FieldConfig[];\n\n/**\n * Creates an HTML element with an optional class name\n * @param {string} tag - HTML tag name\n * @param {string} [className] - Optional CSS class name\n * @returns {HTMLElement} Created element\n */\nfunction createElement<K extends keyof HTMLElementTagNameMap>(\n  tag: K,\n  className?: string,\n): HTMLElementTagNameMap[K] {\n  const el = document.createElement(tag);\n  if (className) el.className = className;\n  return el;\n}\n\n/**\n * Generates a camelCase ID from a name and optional option\n * @param {string} name - Base name for the ID\n * @param {string} [option] - Optional value to append to the ID\n * @returns {string} Generated camelCase ID\n */\nfunction generateId(name: string, option: string | null = null): string {\n  const id = toCamelCase(name);\n  return option ? `${id}-${toCamelCase(option)}` : id;\n}\n\n/**\n * Creates a help text paragraph with a unique ID\n * @param {string} text - Help text content\n * @param {string} inputId - ID of the associated input field\n * @returns {HTMLParagraphElement} Help text element\n */\nfunction writeHelpText(text: string, inputId: string): HTMLParagraphElement {\n  const help = createElement('p', 'field-help-text');\n  help.textContent = text;\n  help.id = `${inputId}-help`;\n  return help;\n}\n\n/**\n * Creates a label or legend element\n * @param {string} text - Label text content\n * @param {string} [type='label'] - Either 'label' or 'legend'\n * @param {string} [id] - ID of the associated input (for 'label' type only)\n * @param {boolean} [required] - Whether the field is required\n * @returns {HTMLElement} Label or legend element\n */\nfunction buildLabel(\n  text: string,\n  type: 'label' | 'legend' = 'label',\n  id: string | null = null,\n  required = false,\n): HTMLElement {\n  const label = createElement(type);\n  label.textContent = text;\n  if (id && type === 'label') label.setAttribute('for', id);\n  if (required) label.dataset.required = 'true';\n  return label;\n}\n\n/**\n * Creates an input element with specified attributes\n * @param {Object} field - Field configuration object\n * @returns {HTMLInputElement} Input element\n */\nfunction buildInput(field: FieldConfig): HTMLInputElement {\n  const {\n    type, field: fieldName, required, default: defaultValue, placeholder,\n  } = field;\n\n  const input = createElement('input');\n  input.type = type || 'text';\n  input.id = generateId(fieldName || 'field');\n  input.name = input.id;\n  input.required = required === 'true';\n  if (defaultValue) input.value = defaultValue;\n  if (placeholder) input.placeholder = placeholder;\n  return input;\n}\n\n/**\n * Creates a textarea element\n * @param {Object} field - Field configuration object\n * @returns {HTMLTextAreaElement} Textarea element\n */\nfunction buildTextArea(field: FieldConfig): HTMLTextAreaElement {\n  const {\n    field: fieldName, required, default: defaultValue, placeholder,\n  } = field;\n\n  const textarea = createElement('textarea');\n  textarea.id = generateId(fieldName || 'field');\n  textarea.name = textarea.id;\n  textarea.required = required === 'true';\n  textarea.rows = 5;\n  if (defaultValue) textarea.value = defaultValue;\n  if (placeholder) textarea.placeholder = placeholder;\n  return textarea;\n}\n\n/**\n * Creates a radio/checkbox input for an option\n * @param {Object} field - Field configuration object\n * @param {string} option - Option value\n * @returns {HTMLInputElement} Radio/checkbox input\n */\nfunction buildOptionInput(field: FieldConfig, option: string): HTMLInputElement {\n  const {\n    type, field: fieldName, default: defaultValue, required,\n  } = field;\n  const id = generateId(fieldName || 'field', option);\n\n  const input = createElement('input');\n  input.type = type || 'text';\n  input.id = id;\n  input.name = generateId(fieldName || 'field');\n  input.value = option;\n  input.checked = option === defaultValue;\n  input.required = required === 'true';\n\n  return input;\n}\n\n/**\n * Creates a fieldset containing radio/checkbox options\n * @param {Object} field - Field configuration object\n * @param {string} controlled - Controlled field name\n * @returns {HTMLFieldSetElement} Fieldset containing options\n */\nfunction buildOptions(field: FieldConfig, controlled: string | null): HTMLFieldSetElement | null {\n  const {\n    type, options, label, required,\n  } = field;\n  if (!options) return null;\n\n  const fieldset = createElement('fieldset', `form-field ${type}-field`);\n  if (controlled) {\n    const controller = controlled.split('-')[0];\n    fieldset.dataset.controller = controller;\n    fieldset.dataset.condition = controlled;\n  }\n  fieldset.append(buildLabel(label || '', 'legend', null, required === 'true'));\n\n  options.split(',').forEach((o) => {\n    const option = o.trim();\n    const input = buildOptionInput(field, option);\n    const span = createElement('span');\n    const labelEl = buildLabel(option, 'label', input.id);\n    labelEl.prepend(input, span);\n    fieldset.append(labelEl);\n  });\n\n  return fieldset;\n}\n\n/**\n * Fetches select options from a remote URL\n * @param {URL} url - URL to fetch options from\n * @returns {Promise<Array<HTMLOptionElement>>} Array of option elements\n */\nasync function buildOptionsFromUrl(url: URL): Promise<HTMLOptionElement[]> {\n  const resp = await fetch(url);\n  const { data } = (await resp.json()) as { data: Array<{ option?: string; value?: string }> };\n  const options = data.map((o) => {\n    const { option, value } = o;\n    const optionEl = createElement('option');\n    if (option && value) {\n      optionEl.value = value;\n      optionEl.textContent = option;\n    } else if (option && !value) {\n      optionEl.value = option;\n      optionEl.textContent = option;\n    } else if (value && !option) {\n      optionEl.value = value;\n      optionEl.textContent = value;\n    }\n    return optionEl;\n  });\n  return options;\n}\n\n/**\n * Creates a select dropdown field\n * @param {Object} field - Field configuration object\n * @param {string} controlled - Controlled field name\n * @returns {HTMLElement} Wrapper div containing select element\n */\nfunction buildSelect(field: FieldConfig, controlled: string | null): HTMLElement | null {\n  const {\n    type, options, field: fieldName, label, required, placeholder,\n  } = field;\n  if (!options) return null;\n\n  const wrapper = createElement('div', `form-field ${(type || 'text')}-field`);\n  if (controlled) {\n    const controller = controlled.split('-')[0];\n    wrapper.dataset.controller = controller;\n    wrapper.dataset.condition = controlled;\n  }\n  wrapper.append(buildLabel(label || '', 'label', generateId(fieldName || 'field'), required === 'true'));\n\n  const select = createElement('select');\n  select.id = generateId(fieldName || 'field');\n  select.name = select.id;\n  select.required = required === 'true';\n  wrapper.append(select);\n\n  if (placeholder) {\n    const placeholderOption = createElement('option');\n    placeholderOption.value = '';\n    placeholderOption.textContent = placeholder;\n    placeholderOption.disabled = true;\n    placeholderOption.selected = true;\n    select.append(placeholderOption);\n  }\n\n  try {\n    const url = new URL(options);\n    buildOptionsFromUrl(url).then((os) => {\n      select.append(...os);\n    });\n  } catch (error) {\n    options.split(',').forEach((o) => {\n      const option = o.trim();\n      const optionEl = createElement('option');\n      optionEl.value = option;\n      optionEl.textContent = option;\n      select.append(optionEl);\n    });\n  }\n\n  return wrapper;\n}\n\n/**\n * Creates a toggle switch field (styled checkbox)\n * @param {Object} field - Field configuration object\n * @param {string} controlled - Controlled field name\n * @returns {HTMLElement} Wrapper div containing toggle switch\n */\nfunction buildToggle(field: FieldConfig, controlled: string | null): HTMLElement {\n  const {\n    label, required, default: defaultValue,\n  } = field;\n\n  const wrapper = createElement('div', 'form-field toggle-field');\n  if (controlled) {\n    const controller = controlled.split('-')[0];\n    wrapper.dataset.controller = controller;\n    wrapper.dataset.condition = controlled;\n  }\n\n  const input = buildOptionInput({ ...field, type: 'checkbox' }, defaultValue || 'true');\n  input.setAttribute('role', 'switch');\n  input.setAttribute('aria-checked', String(input.checked));\n\n  input.addEventListener('change', () => {\n    input.setAttribute('aria-checked', String(input.checked));\n  });\n\n  const span = createElement('span');\n  const labelEl = buildLabel(label || '', 'label', input.id, required === 'true');\n  labelEl.prepend(input, span);\n  wrapper.append(labelEl);\n\n  return wrapper;\n}\n\n/**\n * Creates a button element\n * @param {Object} field - Field configuration object\n * @returns {HTMLButtonElement} Button element\n */\nfunction buildButton(field: FieldConfig): HTMLButtonElement {\n  const { type, label } = field;\n  const button = createElement('button');\n  button.className = 'button';\n  button.type = (type as 'button' | 'submit' | 'reset') || 'button';\n  button.textContent = label || '';\n  if (type === 'reset') button.classList.add('secondary');\n  return button;\n}\n\n/**\n * Toggles visibility of conditional fields based on the selected input\n * @param {Event} e - Change event\n * @param {Map} controllerConfig - Map of controller names to controlled fields\n */\nfunction toggleConditional(e: Event, controllerConfig: Map<string, FormControlElement[]>) {\n  const { target } = e;\n  const controller = (target as HTMLInputElement).name;\n  // check if this is a controlling input\n  if (controllerConfig.has(controller)) {\n    const inputs = [...(controllerConfig.get(controller) || [])];\n    inputs.forEach((i) => {\n      const field = i.closest('.form-field') as HTMLElement;\n      const { condition } = field.dataset;\n      const conditionMet = condition\n        ? condition.includes(toClassName((target as HTMLInputElement).value))\n        : false;\n      field.setAttribute('aria-hidden', String(!conditionMet));\n\n      // toggle required and tabindex based on visibility\n      if (conditionMet) {\n        if (i.dataset.originalRequired === 'true') {\n          i.setAttribute('required', '');\n        }\n        i.removeAttribute('tabindex');\n      } else {\n        i.removeAttribute('required');\n        i.setAttribute('tabindex', '-1'); // remove from tab order when hidden\n      }\n    });\n  }\n}\n\n/**\n * Sets initial visibility of conditional fields based on default values.\n * @param {HTMLFormElement} form - Form element\n * @param {Map} controllerConfig - Map of controller names to controlled fields.\n */\nfunction initConditionals(form: HTMLFormElement, controllerConfig: Map<string, FormControlElement[]>) {\n  // for each controller, find its current value and apply conditions\n  controllerConfig.forEach((controlledInputs, controller) => {\n    // find the controlling input - could be radio/checkbox or select\n    let controllerValue: string | null = null;\n    const checked = form.querySelector(`[name=\"${controller}\"]:checked`) as HTMLInputElement | null;\n    const select = form.querySelector(`select[name=\"${controller}\"]`) as HTMLSelectElement | null;\n\n    if (checked) {\n      controllerValue = checked.value;\n    } else if (select) {\n      controllerValue = select.value;\n    }\n\n    if (controllerValue) {\n      const safeValue = controllerValue;\n      // set correct visibility for each controlled field\n      controlledInputs.forEach((input) => {\n        const field = input.closest('.form-field') as HTMLElement;\n        const { condition } = field.dataset;\n        const conditionMet = condition ? condition.includes(toClassName(safeValue)) : false;\n        field.setAttribute('aria-hidden', String(!conditionMet));\n\n        // store original required state and toggle based on visibility\n        if (input.hasAttribute('required')) {\n          // store original required state if not already stored\n          if (!input.dataset.originalRequired) {\n            input.dataset.originalRequired = 'true';\n          }\n\n          if (!conditionMet) {\n            input.removeAttribute('required');\n          }\n        }\n\n        // remove from tab order when hidden\n        if (conditionMet) {\n          input.removeAttribute('tabindex');\n        } else {\n          input.setAttribute('tabindex', '-1');\n        }\n      });\n    } else {\n      // if no input is checked, hide all controlled fields\n      controlledInputs.forEach((input) => {\n        const field = input.closest('.form-field') as HTMLElement;\n        field.setAttribute('aria-hidden', 'true');\n\n        // remove required attribute when hidden\n        if (input.hasAttribute('required')) {\n          // store original required state if not already stored\n          if (!input.dataset.originalRequired) {\n            input.dataset.originalRequired = 'true';\n          }\n          input.removeAttribute('required');\n        }\n\n        // remove from tab order when hidden\n        input.setAttribute('tabindex', '-1');\n      });\n    }\n  });\n}\n\n/**\n * Sets up conditional field visibility and ARIA relationships\n * @param {HTMLFormElement} form - Form element\n */\nfunction enableConditionals(form: HTMLFormElement) {\n  // find controlled fields\n  const controlled = [...form.querySelectorAll<HTMLElement>('[data-controller]')];\n\n  // create a map of controller names to controlled fields\n  const controllerConfig = new Map<string, FormControlElement[]>();\n\n  controlled.forEach((c) => {\n    const input = c.querySelector('input, textarea, select') as FormControlElement | null;\n    const { controller } = c.dataset;\n\n    // add to controller map\n    if (!input) return;\n    if (!controller) return;\n    if (!controllerConfig.has(controller)) controllerConfig.set(controller, []);\n    (controllerConfig.get(controller) || []).push(input);\n\n    // set up aria relationships\n    if (input && input.id) {\n      // find the controlling input(s)\n      const controllerInputs = form.querySelectorAll(`[name=\"${controller}\"]`);\n\n      // set aria-controls on controlling inputs\n      controllerInputs.forEach((controllerInput) => {\n        // get existing aria-controls or initialize empty\n        const existingControls = controllerInput.getAttribute('aria-controls') || '';\n        const controlsArray = existingControls.split(' ').filter((ec) => ec);\n\n        // add this input's id if not already present\n        if (!controlsArray.includes(input.id)) {\n          controlsArray.push(input.id);\n        }\n\n        // update aria-controls attribute\n        controllerInput.setAttribute('aria-controls', controlsArray.join(' '));\n\n        // set aria-controlledby on the controlled input\n        input.setAttribute('aria-controlledby', controllerInput.id);\n      });\n    }\n  });\n\n  // initialize conditional visibility\n  initConditionals(form, controllerConfig);\n\n  // add single event listener for ALL controlling inputs\n  form.addEventListener('change', (e) => {\n    toggleConditional(e, controllerConfig);\n  });\n}\n\n/**\n * Enables or disables all form elements\n * @param {HTMLFormElement} form - Form element\n * @param {boolean} [disabled=true] - Whether to disable the form\n */\nfunction toggleForm(form: HTMLFormElement, disabled = true) {\n  [...form.elements].forEach((el) => {\n    const control = el as FormControlElement;\n    if (control && 'disabled' in control) {\n      control.disabled = disabled;\n    }\n  });\n}\n\n/**\n * Generates form submission payload from form elements\n * @param {HTMLFormElement} form - Form element\n * @returns {Object} Payload object with form data\n */\nfunction generatePayload(form: HTMLFormElement): Record<string, string> {\n  const payload = {};\n  [...form.elements].forEach((field) => {\n    const typedField = field as HTMLInputElement;\n    if (typedField.name && !typedField.disabled) {\n      if (typedField.type === 'radio') {\n        if (typedField.checked) payload[typedField.name] = typedField.value;\n      } else if (typedField.type === 'checkbox') {\n        if (typedField.checked) {\n          payload[typedField.name] = payload[typedField.name]\n            ? `${payload[typedField.name]},${typedField.value}`\n            : typedField.value;\n        }\n      } else {\n        payload[typedField.name] = typedField.value;\n      }\n    }\n  });\n  return payload;\n}\n\n/**\n * Handles form submission\n * @param {HTMLFormElement} form - Form element to submit\n * @returns {Promise<void>}\n */\nasync function handleSubmit(form: HTMLFormElement): Promise<void> {\n  try {\n    const payload = generatePayload(form);\n    toggleForm(form);\n    if (!form.dataset.action) throw new Error('Missing form action');\n    const response = await fetch(form.dataset.action, {\n      method: 'POST',\n      body: JSON.stringify({ data: payload }),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n    if (response.ok) {\n      if (form.dataset.confirmation) {\n        window.location.href = form.dataset.confirmation;\n      }\n    } else {\n      const error = await response.text();\n      throw new Error(error);\n    }\n  } catch (error) {\n    // eslint-disable-next-line no-console\n    console.error(error);\n  } finally {\n    toggleForm(form, false);\n  }\n}\n\n/**\n * Sets up form submission handler\n * @param {HTMLFormElement} form - Form element\n * @param {string} submit - Submit URL\n * @param {Array<Object>} fields - Array of field configurations\n */\nfunction enableSubmission(form: HTMLFormElement, submit: string, fields: FieldList) {\n  form.dataset.action = submit;\n  const confirmation = fields.find((f) => f.type === 'confirmation');\n  if (confirmation) {\n    form.dataset.confirmation = confirmation.label || confirmation.default;\n  }\n\n  form.addEventListener('submit', (e) => {\n    e.preventDefault();\n\n    const valid = form.reportValidity();\n    if (valid) {\n      handleSubmit(form);\n    } else {\n      const firstInvalid = form.querySelector(':invalid:not(fieldset)') as HTMLElement | null;\n      if (firstInvalid) {\n        firstInvalid.focus();\n        firstInvalid.scrollIntoView({ behavior: 'smooth', block: 'center' });\n        firstInvalid.setAttribute('aria-invalid', 'true');\n      }\n    }\n  });\n\n  // clear aria-invalid on field change\n  form.addEventListener('input', (e) => {\n    const target = e.target as HTMLInputElement;\n    if (target?.hasAttribute('aria-invalid')) {\n      if (target.validity.valid) {\n        target.removeAttribute('aria-invalid');\n      }\n    }\n  });\n}\n\n/**\n * Creates a form field based on field configuration\n * @param {Object} field - Field configuration object\n * @returns {HTMLElement} Form field element (fieldset, div, or button)\n */\nfunction buildField(field: FieldConfig): HTMLElement {\n  const {\n    type, label, help, field: fieldName, conditional,\n  } = field;\n  const controlled = conditional || null;\n  const safeFieldName = fieldName || 'field';\n\n  if (type === 'hidden') {\n    return buildInput(field);\n  }\n\n  // submit/reset buttons stand alone\n  if (type === 'submit' || type === 'reset') {\n    return buildButton(field);\n  }\n\n  // radio/checkbox groups get a fieldset\n  if (type === 'radio' || type === 'checkbox') {\n    const fieldset = buildOptions(field, controlled);\n    if (fieldset && help) {\n      const helpText = writeHelpText(help, generateId(safeFieldName));\n      fieldset.append(helpText);\n    }\n    return fieldset || createElement('div');\n  }\n\n  if (type === 'toggle') {\n    const toggle = buildToggle(field, controlled);\n    if (help) {\n      const helpText = writeHelpText(help, generateId(safeFieldName));\n      toggle.append(helpText);\n    }\n    return toggle;\n  }\n\n  if (type === 'select') {\n    const select = buildSelect(field, controlled);\n    if (select && help) {\n      const helpText = writeHelpText(help, generateId(safeFieldName));\n      select.append(helpText);\n    }\n    return select || createElement('div');\n  }\n\n  // inputs and textareas get a wrapper div\n  const wrapper = createElement('div', `form-field ${type}-field`);\n  if (controlled) {\n    const controller = controlled.split('-')[0];\n    wrapper.dataset.controller = controller;\n    wrapper.dataset.condition = controlled;\n  }\n  const inputId = generateId(safeFieldName);\n  wrapper.append(buildLabel(label || '', 'label', inputId, field.required === 'true'));\n\n  // create help text first to get id\n  let helpText: HTMLParagraphElement | undefined;\n  if (help) {\n    helpText = writeHelpText(help, inputId);\n    wrapper.append(helpText);\n  }\n\n  const input = type === 'textarea' ? buildTextArea(field) : buildInput(field);\n\n  if (type === 'textarea') {\n    wrapper.append(input);\n  } else if (wrapper.firstChild) {\n    wrapper.insertBefore(input, wrapper.firstChild.nextSibling);\n  } else {\n    wrapper.append(input);\n  }\n\n  if (helpText) input.setAttribute('aria-describedby', helpText.id);\n\n  return wrapper;\n}\n\n/**\n * Creates a complete form from field configurations\n * @param {Array<Object>} fields - Array of field configurations\n * @returns {HTMLFormElement} Complete form element\n */\nfunction buildForm(fields: FieldList, submit?: string): HTMLFormElement {\n  const form = createElement('form');\n  form.setAttribute('novalidate', '');\n\n  // group buttons at the end\n  const buttons: FieldConfig[] = [];\n\n  fields.forEach((field) => {\n    if (field.type === 'submit' || field.type === 'reset') {\n      buttons.push(field);\n    } else if (field.type !== 'confirmation') {\n      form.append(buildField(field));\n    }\n  });\n\n  // add buttons in a wrapper (if any)\n  if (buttons.length) {\n    const buttonWrapper = createElement('div', 'button-wrapper');\n    buttons.forEach((button) => buttonWrapper.append(buildField(button)));\n    form.append(buttonWrapper);\n  }\n\n  enableConditionals(form);\n\n  if (submit) enableSubmission(form, submit, fields);\n\n  return form;\n}\n\nfunction getFormConfigValue(fields: FieldList, name: string, fallback = ''): string {\n  const entry = fields.find((field) => field.field === name);\n  if (!entry) return fallback;\n  if (entry.default) return entry.default;\n  if (entry.value) return entry.value;\n  return fallback;\n}\n\nfunction initOtpBehavior(form: HTMLFormElement, fields: FieldList) {\n  const otpFieldName = 'otp';\n  const resendTimerSeconds = 30;\n  const resendLimit = 3;\n  const otpErrorThreshold = 0;\n  const resendLimitMessage = getFormConfigValue(\n    fields,\n    'resendLimitMessage',\n    'Resend OTP limit exhausted.',\n  );\n  const otpErrorRedirect = '';\n  const resendLabel = 'Resend OTP';\n  const resendLoaderLabel = 'Resend available in';\n  const otpSuccessRedirect = '/thank-you';\n  const otpRetryMessage = 'Invalid OTP. Please try again.';\n\n  const otpInput = form.querySelector(`input[name=\"${toCamelCase(otpFieldName)}\"]`) as HTMLInputElement | null;\n  if (!otpInput) return;\n\n  const otpField = otpInput.closest('.form-field') as HTMLElement | null;\n  if (!otpField) return;\n\n  const resendWrapper = createElement('div', 'otp-resend');\n  const loader = createElement('div', 'otp-resend__loader');\n  const loaderText = createElement('span', 'otp-resend__loader-text');\n  const timerText = createElement('span', 'otp-resend__timer');\n  loader.append(loaderText, timerText);\n\n  const resendButton = createElement('button', 'otp-resend__button');\n  resendButton.type = 'button';\n  resendButton.textContent = resendLabel;\n\n  const limitMessage = createElement('div', 'otp-resend__message');\n  limitMessage.textContent = resendLimitMessage;\n\n  resendWrapper.append(loader, resendButton, limitMessage);\n  otpField.append(resendWrapper);\n\n  const otpRetry = createElement('div', 'otp-verify__message');\n  otpRetry.textContent = otpRetryMessage;\n  otpRetry.style.display = 'none';\n  otpField.append(otpRetry);\n\n  let resendCount = 0;\n  let timerId: number | undefined;\n\n  const setVisibility = (state: 'loading' | 'ready' | 'limit') => {\n    loader.style.display = state === 'loading' ? 'flex' : 'none';\n    resendButton.style.display = state === 'ready' ? 'inline-flex' : 'none';\n    limitMessage.style.display = state === 'limit' ? 'block' : 'none';\n  };\n\n  const startTimer = (duration: number) => {\n    let remaining = Number.isFinite(duration) ? duration : 0;\n    loaderText.textContent = resendLoaderLabel;\n    setVisibility('loading');\n\n    const tick = () => {\n      timerText.textContent = ` ${remaining}s`;\n      if (remaining <= 0) {\n        if (timerId !== undefined) {\n          window.clearInterval(timerId);\n        }\n        timerId = undefined;\n        setVisibility('ready');\n      }\n      remaining -= 1;\n    };\n\n    tick();\n    timerId = window.setInterval(tick, 1000);\n  };\n\n  startTimer(resendTimerSeconds);\n\n  resendButton.addEventListener('click', () => {\n    resendCount += 1;\n    if (resendCount > resendLimit) {\n      setVisibility('limit');\n      return;\n    }\n\n    form.dispatchEvent(new CustomEvent('otp:resend', { bubbles: true }));\n    startTimer(resendTimerSeconds);\n  });\n\n  let otpErrorCount = 0;\n\n  form.addEventListener('submit', () => {\n    if (otpInput && !otpInput.checkValidity()) {\n      otpErrorCount += 1;\n      if (otpErrorThreshold && otpErrorCount >= otpErrorThreshold && otpErrorRedirect) {\n        window.location.href = otpErrorRedirect;\n      }\n    }\n  });\n\n  form.addEventListener('submit', (e) => {\n    e.preventDefault();\n    otpRetry.style.display = 'none';\n\n    const valid = form.reportValidity();\n    if (!valid) {\n      const firstInvalid = form.querySelector(':invalid:not(fieldset)') as HTMLElement | null;\n      if (firstInvalid) {\n        firstInvalid.focus();\n        firstInvalid.scrollIntoView({ behavior: 'smooth', block: 'center' });\n        firstInvalid.setAttribute('aria-invalid', 'true');\n      }\n      return;\n    }\n\n    if (otpInput.value === '12345') {\n      window.location.href = otpSuccessRedirect;\n    } else {\n      otpRetry.style.display = 'block';\n      otpInput.focus();\n    }\n  });\n}\n\n/**\n * Initializes form block with data from JSON endpoint\n * @param {HTMLElement} block - Form block element\n */\nexport default function decorate(block: HTMLElement) {\n  block.style.visibility = 'hidden';\n  const configFields: FieldList = [];\n  block.querySelectorAll<HTMLTableRowElement>('tr').forEach((row) => {\n    const cells = row.querySelectorAll<HTMLTableCellElement>('td, th');\n    if (cells.length >= 2) {\n      const key = cells[0].textContent?.trim() || '';\n      const value = cells[1].textContent?.trim() || '';\n      if (key) {\n        configFields.push({\n          field: key,\n          type: 'hidden',\n          default: value,\n        });\n      }\n    }\n  });\n\n  const staticFields: FieldList = [\n    {\n      field: 'firstName',\n      type: 'text',\n      label: 'First name',\n      placeholder: 'Enter first name',\n      required: 'true',\n    },\n    {\n      field: 'lastName',\n      type: 'text',\n      label: 'Last name',\n      placeholder: 'Enter last name',\n      required: 'true',\n    },\n    {\n      field: 'mobile',\n      type: 'tel',\n      label: 'Mobile number',\n      placeholder: 'Enter mobile number',\n      required: 'true',\n    },\n    {\n      field: 'otp',\n      type: 'text',\n      label: 'OTP',\n      placeholder: 'Enter OTP',\n      required: 'true',\n    },\n    {\n      field: 'submit',\n      type: 'submit',\n      label: 'Verify OTP',\n    },\n  ];\n\n  const form = buildForm(staticFields);\n  initOtpBehavior(form, configFields);\n  block.replaceChildren(form);\n  block.removeAttribute('style');\n}\n"],"names":["createElement","tag","className","el","generateId","name","option","id","toCamelCase","writeHelpText","text","inputId","help","buildLabel","type","required","label","buildInput","field","fieldName","defaultValue","placeholder","input","buildTextArea","textarea","buildOptionInput","buildOptions","controlled","options","fieldset","controller","o","span","labelEl","buildOptionsFromUrl","url","resp","data","value","optionEl","buildSelect","wrapper","select","placeholderOption","os","buildToggle","buildButton","button","toggleConditional","controllerConfig","target","condition","conditionMet","toClassName","initConditionals","form","controlledInputs","controllerValue","checked","safeValue","enableConditionals","c","controllerInput","controlsArray","ec","e","buildField","conditional","safeFieldName","helpText","toggle","buildForm","fields","submit","buttons","buttonWrapper","getFormConfigValue","fallback","entry","initOtpBehavior","otpFieldName","resendLimitMessage","resendLabel","resendLoaderLabel","otpSuccessRedirect","otpRetryMessage","otpInput","otpField","resendWrapper","loader","loaderText","timerText","resendButton","limitMessage","otpRetry","resendCount","timerId","setVisibility","state","startTimer","duration","remaining","tick","firstInvalid","decorate","block","configFields","row","cells","key","_a","_b"],"mappings":"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"}